# Uses probabilistic programming to construct a model for a real 
# world scenario: The energy generated by a windmill each month. 
# The system works as follows:
#   - Each month, there is a 1% chance of a major failure, resulting in no 
#     energy being produced that month
#   - If there is no major failure, there are still a Poisson distributed,
#     number of independent minor failures. Each minor failure reduces the 
#     efficiency of the windmill by a factor of 0.95.
#   - Finally, the energy produced is assumed linear with the wind speed, which 
#     is Rayleigh distributed.
# The mean expected energy generated each month is approximated using a
# coinductive stream, from which the sixth iteration is extracted.
#
# Example run:
#   stack run ghopfl-exe -- -E -d "0.6;0.9;1.3;0.5;0.1;0.006;0.5;1.7;0.9;0.9;0.1;0.3;0.9;1.0;0.1;0.7;1.4;1.1;0.5;0.1;0.4;1.9;0.7;0.9;0.8;0.5" -i tests/probabilistic/real_world.ghopfl -n 
#   The random draws are used up as follows:
#   1: [ major_fail: 0.6;      | wind_speed: 0.9;1.3;      | minor_fail: 0.5;0.1       ]
#   2: [ major_fail: 0.006     | wind_speed: N/A           | minor_fail: N/A           ]
#   3: [ major_fail: 0.5;      | wind_speed: 1.7;0.9;      | minor_fail: 0.9;0.1       ]
#   4: [ major_fail: 0.3;      | wind_speed: 0.9;1.0;      | minor_fail: 0.1           ]
#   5: [ major_fail: 0.7;      | wind_speed: 1.4;1.1;      | minor_fail: 0.5;0.1       ]
#   6: [ major_fail: 0.4;      | wind_speed: 1.9;0.7;      | minor_fail: 0.9;0.8;0.5   ]

let
    # The Euclidian norm of two standard normally distributed variables
    # follows the Rayleigh distribution
    sample_rayleigh ← (
        sqrt ( ( normal (0.0, 1.0) ) ^ 2 + ( normal (0.0, 1.0) ) ^ 2 )
    ) ;

    # Recursively sample [0,1] in such a way 
    # that the result is poisson distributed
    poisson ← ( λ l . fix f . λ p .
        if ( p < exp ( - l ) )
            then dres_now (-1)
            else dres_map ( add 1 ) 
                ( dres_later ( f ⊙ next ( p * rand ) ) )
    ) ;

    #  Samples poisson with mean 1.0
    sample_poisson ← ( poisson 1.0 1.0 ) ;

    # There is a 1% chance of a major error that takes an entire day to fix
    major_failure ← ( rand < 0.01 ) ;

    # There are a poisson distributed number of independent smaller failures
    # that may occur in a day, each decreasing the efficiency by 5%
    minor_failures_effect ← ( dres_map ( power 0.95 ) sample_poisson ) ;

    # The wind speed (in 2D) depends on two normally distributed variables:
    # the speed in the x-direction and the speed in the y-direction
    wind_speed ← ( sample_rayleigh ) ;

    energy_per_speed_unit ← ( 5000 ) ;

    # Samples the energy produced per day
    energy_produced_daily ← (
        if ( major_failure ) then ( dres_now 0 ) else (
            dres_map ( multiply
                ( energy_per_speed_unit * wind_speed )
            ) 
            minor_failures_effect
        )
    ) ;
    
    # Infinite stream of samples
    sample_stream ← ( fix f .
        in ( energy_produced_daily, f )
    ) ;

    # Recalculates avg given a new value 
    avg_step ← ( λ avg . λ new_val . λ old_count .
        dres_func2 divide 
            ( dres_func2 add 
                ( dres_func2 multiply 
                    avg old_count 
                ) new_val 
            ) ( dres_map ( add 1 ) old_count )
    ) ;

    # Stream of better and better mean approximations
    mean_stream ← ( ( fix f . λ mean . λ c . λ s .
        in ( mean, 
            f   ⊙ next ( avg_step mean ( s_head_g s ) c )
                ⊙ next ( dres_map ( add 1 ) c )
                ⊙ ( s_tail_g s )
        )
    ) ( dres_now 0.0 ) ( dres_now 0 ) ) ;

in: force ( s_idx_g 6 ( mean_stream ( sample_stream ) ) )

