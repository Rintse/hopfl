# Builtin function definitions for common list operations
let
   
# Allows for application of boxed functions
#   Type: [] (A -> B) -> [] A -> [] B
limit   â† ( Î» func . Î» x . 
    boxI ( ( unbox func ) ( unbox x ) )
) ;

# Coinductive list construction
l_empty â† ( boxI ( in ( inL ğŸ™ ) ) ) ;
l_empty_gl â† ( in ( inL ğŸ™ ) ) ;
cons â† ( Î» e . Î» l . boxI ( in ( inR ( e, next ( unbox l ) ) ) ) ) ;
cons_gl â† ( Î» e . Î» l . in ( inR ( e, l ) ) ) ;

# Basic functions
head    â† ( Î» l . match ( out ( unbox l ) ) { 
    inL x â†’ x ; 
    inR y â†’ fst y 
} ) ;

head_gl  â† ( Î» l . match ( out l ) { 
    inL x â†’ x ; 
    inR y â†’ fst y 
} ) ;

tail    â† ( Î» l . match ( out ( unbox l ) ) { 
    inL x â†’ x ; 
    inR y â†’ boxI ( prevI ( snd y ) ) 
} ) ;

tail_gl  â† ( Î» l . match ( out l ) { 
    inL x â†’ x ; 
    inR y â†’ snd y
} ) ;

null    â† ( Î» l . match ( out ( unbox l ) ) { 
    inL x â†’ true ; 
    inR y â†’ false 
} ) ;

# Not well typed!
length  â† ( fix f . Î» l .
    match ( out ( unbox l ) ) {
        inL x â†’ 0 ;
        inR y â†’ 1 + prevI ( f âŠ™ next ( tail l ) )
    }
) ;

# Well typed.
co_length â† ( fix f . Î» l .
    match ( out ( unbox l ) ) {
        inL x â†’ in ( inL ğŸ™ ) ;
        inR y â†’ in ( inR ( f âŠ™ ( next ( tail l ) ) ) )
    }
) ;
    
append  â† ( fix f . Î» l1 . Î» l2 .
    boxI ( match ( out ( unbox l1 ) ) {
        inL end â†’ unbox l2 ;
        inR lst â†’ unbox ( cons ( head l1 ) 
            ( prevI ( f âŠ™ next ( tail l1 ) âŠ™ next l2 ) )
        )
    } )
) ;

# Access
index â† ( fix f . Î» idx . Î» list .
    if ( idx = 0 )
        then head list
        else prevI ( f âŠ™ next (idx - 1) âŠ™ next (tail list) )
) ;

co_index â† ( fix f . Î» idx . Î» list .
    match (out idx) {
        inL x â†’ head list ;
        inR y â†’ prevI ( f âŠ™ next ( l ) )
    }
) ;

# Sublists
take_gl â† ( fix f . Î» n . Î» list .
    match ( out list ) {
        inL x â†’ list ;
        inR y â†’ if ( n = 0 )
            then l_empty_gl
            else cons_gl ( head_gl list ) ( 
                f âŠ™ next ( n - 1 ) âŠ™ ( tail_gl list ) 
            )
    }
) ;

take â† ( Î» n . Î» list .
    limit ( boxI ( take_gl n ) ) list
) ;

edit_gl â† ( fix f . Î» n . Î» func . Î» list .
    match ( out list ) {
        inL x â†’ list ;
        inR y â†’ if ( n = 0 )
            then cons_gl ( func ( head_gl list ) ) ( tail_gl list )
            else cons_gl ( head_gl list ) ( 
                f âŠ™ next ( n - 1 ) âŠ™ next func âŠ™ ( tail_gl list ) 
            )
    }
) ;

edit â† ( Î» n . Î» func . 
    limit ( boxI ( edit_gl n func ) )
) ;

# Ill-typed!
drop â† (fix f . Î» n . Î» list . 
    match ( out ( unbox list ) ) { 
        inL end â†’ list ;
        inR lst â†’ if ( n = 0 ) 

            then list
            else prevI ( f âŠ™ next ( n - 1 ) âŠ™ next ( tail list ) )
    }
) ;

# Tranformations
# func and val must have a constant type!

map_gl  â† ( Î» func . fix f . Î» list .
    match ( out list ) {
        inL end â†’ list ;
        inR lst â†’ cons_gl ( func ( head_gl list ) ) 
            ( f âŠ™ ( tail_gl list ) )
    }
) ;

map â† ( Î» func . Î» list .
    limit ( boxI ( map_gl func ) ) list
) ;
    
# Folds: Not typable!
# func and val must have a constant type!
foldl   â† ( fix f . Î» func . Î» val . Î» list .
    match ( out ( unbox list ) ) {
        inL end â†’ val ;
        inR lst â†’ prevI ( 
            f âŠ™ next func 
              âŠ™ next ( func ( head list ) val )
              âŠ™ next ( tail list )
        )
    }
) ;

foldr   â† ( fix f . Î» func . Î» val . Î» list .
    match ( out ( unbox list ) ) {
        inL end â†’ val ;
        inR lst â†’ func ( prevI ( 
            f âŠ™ next func 
              âŠ™ next ( val )
              âŠ™ next ( tail l )
        ) ) ( head l )
    }
) ;

in: builtin
