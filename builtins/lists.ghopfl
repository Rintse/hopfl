# Builtin function definitions for common list operations
let
   
# Coinductive list construction
l_empty â† ( boxI ( in ( inL ğŸ™ ) ) );
cons â† ( Î» e . Î» l . boxI ( in ( inR ( e, next ( unbox l ) ) ) ) ) ;

# Basic functions
head    â† ( Î» l . match ( out ( unbox l ) ) { inL x â†’ x ; inR y â†’ fst y } ) ;
tail    â† ( Î» l . match ( out ( unbox l ) ) { inL x â†’ x ; inR y â†’ boxI ( prevI ( snd y ) ) } ) ;
null    â† ( Î» l . match ( out ( unbox l ) ) { inL x â†’ true ; inR y â†’ false } ) ;

length  â† ( fix f . Î» l .
    match ( out ( unbox l ) ) {
        inL x â†’ 0 ;
        inR y â†’ 1 + prevI ( f âŠ™ next ( tail l ) )
    }
) ;
    
append  â† ( fix f . Î» l1 . Î» l2 .
    boxI ( match ( out ( unbox l1 ) ) {
        inL end â†’ unbox l2 ;
        inR lst â†’ unbox ( cons ( head l1 ) 
            ( prevI ( f âŠ™ next ( tail l1 ) âŠ™ next l2 ) )
        )
    } )
) ;

elem â† ( fix f . Î» e . Î» l .
    match ( out ( unbox l ) ) {
        inL x â†’ false ;
        inR lst â†’ if ( ( head l ) = e )
            then true
            else ( prevI ( f âŠ™ next e âŠ™ next ( tail l ) ) )
    }
) ;


# Access
index â† ( fix f . Î» idx . Î» list .
    if ( idx = 0 )
        then head list
        else prevI ( f âŠ™ next (idx - 1) âŠ™ next (tail list) )
) ;


# Sublists
take    â† ( fix f . Î» n . Î» l . 
    match ( out ( unbox l ) ) {
        inL end â†’ l ;
        inR lst â†’ if (n = 0)
            then l_empty
            else cons ( head l )
                ( prevI ( f âŠ™ next ( n - 1 ) âŠ™ next ( tail l ) ) )
    }
) ;

drop    â† ( fix f . Î» n . Î» l .
    match ( out ( unbox l ) ) {
        inL end â†’ l ;
        inR lst â†’ 
            ( if ( n = 0 ) 
                then ( cons ( head l ) )
                else (Î» x . x) 
            ) ( prevI ( 
                f âŠ™ next ( if ( n = 0 ) then 0 else n - 1 )
                  âŠ™ next ( tail l )
            ) )
    }
) ;

filter  â† ( fix f . Î» pred . Î» l .
    match ( out ( unbox l ) ) {
        inL end â†’ l ;
        inR lst â†’ 
            ( if ( pred ( head l ) )
                then ( cons ( head l ) ) 
                else (Î» x . x) 
            ) ( prevI ( 
                f âŠ™ next pred âŠ™ next ( tail l ) 
            ) )
    }
) ;


# Tranformations
map     â† ( fix f . Î» func . Î» l .
    match ( out ( unbox l ) ) {
        inL end â†’ l ;
        inR lst â†’ cons ( func ( head l ) )
            ( prevI ( f âŠ™ next func âŠ™ next ( tail l ) ) )
    }
) ;
    
reverse â† ( fix f . Î» l .
    match ( out ( unbox l ) ) {
        inL x â†’ l ;
        inR lst â†’ append ( prevI ( f âŠ™ next ( tail l ) ) ) [ head l ]
    }
) ;


# Folds
foldl   â† ( fix f . Î» func . Î» val . Î» l .
    match ( out ( unbox l ) ) {
        inL end â†’ val ;
        inR lst â†’ prevI ( 
            f âŠ™ next func 
              âŠ™ next ( func ( head l ) val )
              âŠ™ next ( tail l )
        )
    }
) ;

foldr   â† ( fix f . Î» func . Î» val . Î» l .
    match ( l ) {
        inL end â†’ val ;
        inR lst â†’ func ( prevI ( 
            f âŠ™ next func 
              âŠ™ next ( val )
              âŠ™ next ( tail l )
        ) ) ( head l )
    }
) ;

in: builtin
