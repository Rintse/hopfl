# Builtin function definitions for common list operations
let
    
# Coinductive list construction
cons ← ( λ e . λ l . inR ( e, l ) ) ;

# Basic functions
head    ← ( λ l . match l { inL x → x ; inR y → fst y } ) ;
tail    ← ( λ l . match l { inL x → x ; inR y → snd y } ) ;
null    ← ( λ l . match l { inL x → true ; inR y → false } ) ;

length  ← ( fix f . λ l .
    match l {
        inL x → 0 ;
        inR y → 1 + prevI ( f ⊙ next ( snd y ) )
    }
) ;
    
append  ← ( fix f . λ l1 . λ l2 .
    match l1 {
        inL end → l2 ;
        inR lst → cons ( fst lst ) 
            ( prevI ( f ⊙ next (snd lst) ⊙ next l2 ) )
    }
) ;

elem ← ( fix f . λ e . λ l .
    match l {
        inL x → false ;
        inR lst → if ( ( fst lst ) = e )
            then true
            else ( prevI ( f ⊙ next e ⊙ next ( snd lst ) ) )
    }
) ;


# Access
index ← ( fix f . λ idx . λ list .
    if ( idx = 0 )
        then head list
        else prevI ( f ⊙ next (idx - 1) ⊙ next (tail list) )
) ;


# Sublists
take    ← ( fix f . λ n . λ l . 
    match l {
        inL end → l ;
        inR lst → if (n = 0)
            then inL 𝟙
            else cons ( fst lst )
                ( prevI ( f ⊙ next (n-1) ⊙ next (snd lst) ) )
    }
) ;

drop    ← ( fix f . λ n . λ l .
    match l {
        inL end → l ;
        inR lst → 
            ( if ( n = 0 ) 
                then ( cons ( fst lst ) )
                else (λ x . x) 
            ) ( prevI ( 
                f ⊙ next (if ( n = 0 ) then 0 else n - 1) 
                  ⊙ next (snd lst) 
            ) )
    }
) ;

filter  ← ( fix f . λ pred . λ l .
    match l {
        inL end → l ;
        inR lst → 
            ( if ( pred ( fst lst ) )
                then ( cons ( fst lst ) ) 
                else (λ x . x) 
            ) ( prevI ( 
                f ⊙ next pred ⊙ next (snd lst) 
            ) )
    }
) ;


# Tranformations
map     ← ( fix f . λ func . λ list .
    match list {
        inL end → list ;
        inR lst → inR ( func ( fst lst ), prevI (
            f ⊙ next func ⊙ next ( snd lst )
        ) )
    }
) ;
    
reverse ← ( fix f . λ l .
    match l {
        inL x → l ;
        inR lst → append ( prevI ( f ⊙ next (snd lst) ) ) [fst lst]
    }
) ;


# Folds
foldl   ← ( fix f . λ func . λ val . λ list .
    match ( list ) {
        inL end → val ;
        inR lst → prevI ( 
            f ⊙ next func 
              ⊙ next ( func ( fst lst ) val )
              ⊙ next ( snd lst )
        )
    }
) ;

foldr   ← ( fix f . λ func . λ val . λ list .
    match ( list ) {
        inL end → val ;
        inR lst → func ( prevI ( 
            f ⊙ next func 
              ⊙ next ( val )
              ⊙ next ( snd lst )
        ) ) ( fst lst )
    }
) ;

in: builtin
