# Builtin function definitions for common list operations
let
   
# Coinductive list construction
l_empty ← ( boxI ( in ( inL 𝟙 ) ) );
cons ← ( λ e . λ l . boxI ( in ( inR ( e, next ( unbox l ) ) ) ) ) ;

# Basic functions
head    ← ( λ l . match ( out ( unbox l ) ) { 
    inL x → x ; 
    inR y → fst y 
} ) ;

tail    ← ( λ l . match ( out ( unbox l ) ) { 
    inL x → x ; 
    inR y → boxI ( prevI ( snd y ) ) 
} ) ;

null    ← ( λ l . match ( out ( unbox l ) ) { 
    inL x → true ; 
    inR y → false 
} ) ;

# Not well typed!
length  ← ( fix f . λ l .
    match ( out ( unbox l ) ) {
        inL x → 0 ;
        inR y → 1 + prevI ( f ⊙ next ( tail l ) )
    }
) ;

# Well typed.
co_length ← ( fix f . λ l .
    match ( out ( unbox l ) ) {
        inL x → in ( inL 𝟙 ) ;
        inR y → in ( inR ( f ⊙ ( next ( tail l ) ) ) )
    }
) ;
    
append  ← ( fix f . λ l1 . λ l2 .
    boxI ( match ( out ( unbox l1 ) ) {
        inL end → unbox l2 ;
        inR lst → unbox ( cons ( head l1 ) 
            ( prevI ( f ⊙ next ( tail l1 ) ⊙ next l2 ) )
        )
    } )
) ;

# Access
index ← ( fix f . λ idx . λ list .
    if ( idx = 0 )
        then head list
        else prevI ( f ⊙ next (idx - 1) ⊙ next (tail list) )
) ;

co_index ← ( fix f . λ idx . λ list .
    match (out idx) {
        inL x → head list ;
        inR y → prevI ( f ⊙ next ( l ) )
    }
) ;

# Sublists
take    ← ( fix f . λ n . λ list . 
    match ( out ( unbox list ) ) {
        inL end → list ;
        inR lst → if (n = 0)
            then l_empty
            else cons ( head list ) ( 
                prevI ( f ⊙ next ( n - 1 ) ⊙ next ( tail list ) ) 
            )
    }
) ;

drop ← (fix f . λ n . λ list . 
    match ( out ( unbox list ) ) { 
        inL end → list ;
        inR lst → if ( n = 0 ) 

            then list
            else prevI ( f ⊙ next ( n - 1 ) ⊙ next ( tail list ) )
    }
) ;


filter  ← ( fix f . λ pred . λ list .
    match ( out ( unbox list ) ) {
        inL end → list ;
        inR lst → 
            ( if ( pred ( head list ) )
                then ( cons ( head list ) ) 
                else (λ x . x) 
            ) ( prevI ( 
                f ⊙ next pred ⊙ next ( tail list ) 
            ) )
    }
) ;


# Tranformations
# func and val must have a constant type!
map     ← ( fix f . λ func . λ list .
    match ( out ( unbox list ) ) {
        inL end → list ;
        inR lst → cons ( func ( head list ) )
            ( prevI ( f ⊙ next func ⊙ next ( tail list ) ) )
    }
) ;
    
# Folds
# func and val must have a constant type!
foldl   ← ( fix f . λ func . λ val . λ list .
    match ( out ( unbox list ) ) {
        inL end → val ;
        inR lst → prevI ( 
            f ⊙ next func 
              ⊙ next ( func ( head list ) val )
              ⊙ next ( tail list )
        )
    }
) ;

foldr   ← ( fix f . λ func . λ val . λ list .
    match ( out ( unbox list ) ) {
        inL end → val ;
        inR lst → func ( prevI ( 
            f ⊙ next func 
              ⊙ next ( val )
              ⊙ next ( tail l )
        ) ) ( head l )
    }
) ;

in: builtin
