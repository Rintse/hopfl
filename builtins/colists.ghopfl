# Builtin function definitions for common list operations
let

# GUARDED LISTS
# As we will define most coinductive colist functions as 
# lifts on a guarded analog, we first define some basic 
# operations for guarded lists
# =========================================================
l_empty_gl â† ( in ( inL ğŸ™ ) ) ;
cons_gl â† ( Î» e . Î» l . in ( inR ( e, l ) ) ) ;

# head_gl : glist A -> A
head_gl  â† ( Î» l . match ( out l ) { 
    inL x â†’ x ; # ERROR
    inR y â†’ fst y 
} ) ;

# tail_gl : glist A -> glist A
tail_gl  â† ( Î» l . match ( out l ) { 
    inL x â†’ x ; 
    inR y â†’ snd y
} ) ;

# append_gl -> glist A -> glist A -> glist A
append_gl  â† ( fix f . Î» l2 . Î» list .
    match ( out list ) {
        inL end â†’ l2 ;
        inR lst â†’ cons_gl ( head_gl list ) ( 
            f âŠ™ next l2 âŠ™ ( tail_gl list ) 
        )
    }
) ;

# take_gl : int -> glist A -> glist A
take_gl â† ( fix f . Î» n . Î» list .
    match ( out list ) {
        inL x â†’ list ;
        inR y â†’ if ( n = 0 )
            then l_empty_gl
            else cons_gl ( head_gl list ) ( 
                f âŠ™ next ( n - 1 ) âŠ™ ( tail_gl list ) 
            )
    }
) ;

# edit_gl : int -> (A -> A) -> glist A -> glist A
edit_gl â† ( fix f . Î» n . Î» func . Î» list .
    match ( out list ) {
        inL x â†’ list ;
        inR y â†’ if ( n = 0 )
            then cons_gl ( func ( head_gl list ) ) ( tail_gl list )
            else cons_gl ( head_gl list ) ( 
                f âŠ™ next ( n - 1 ) âŠ™ next func âŠ™ ( tail_gl list ) 
            )
    }
) ;

# map_gl : (A -> B) -> glist A -> glist B
map_gl  â† ( Î» func . fix f . Î» list .
    match ( out list ) {
        inL end â†’ list ;
        inR lst â†’ cons_gl ( func ( head_gl list ) ) 
            ( f âŠ™ ( tail_gl list ) )
    }
) ;


# COINDUCTIVE COLISTS
# =========================================================
# We will extend the functions from the guarded colists to
# coinductive colists using the limit function:
# limit : [] (A -> B) -> [] A -> [] B
limit_gl   â† ( Î» func . Î» x . 
    boxI ( ( unbox func ) ( unbox x ) )
) ;
# As colists are defined as ([] glist), supplying a boxed
# glist function to limit, allows its second argument to be
# a colist

# Coinductive list construction
l_empty â† ( boxI ( in ( inL ğŸ™ ) ) ) ;
cons_cl â† ( Î» e . Î» l . boxI ( in ( inR ( e, next ( unbox l ) ) ) ) ) ;

# Basic functions
# not typable???
# head : colist A -> A
head_cl â† ( Î» l . match ( out ( unbox l ) ) { 
    inL x â†’ x ; 
    inR y â†’ fst y 
} ) ;

# tail : colist A -> colist A
tail_cl â† ( Î» l . match ( out ( unbox l ) ) { 
    inL x â†’ x ; 
    inR y â†’ boxI ( prevI ( snd y ) ) 
} ) ;

# null : colist A -> bool
null_cl â† ( Î» l . match ( out ( unbox l ) ) { 
    inL x â†’ true ; 
    inR y â†’ false 
} ) ;

# Some hard-coded indexation
# l_x : colist A -> A
l_2nd â† ( Î» list . head ( tail list ) ) ;
l_3rd â† ( Î» list . head ( tail ( tail list ) ) ) ;
l_4th â† ( Î» list . head ( tail ( tail ( tail list ) ) ) ) ;

# co_length : colist A -> coNat
co_length â† ( fix f . Î» l .
    match ( out ( unbox l ) ) {
        inL x â†’ in ( inL ğŸ™ ) ;
        inR y â†’ in ( inR ( f âŠ™ ( next ( tail l ) ) ) )
    }
) ;

# Indexation using the conatural numbers
# co_index : colist A -> coNat -> A
co_index â† ( fix f . Î» idx . Î» list .
    match (out idx) {
        inL x â†’ head list ;
        inR y â†’ prevI ( f âŠ™ next ( l ) )
    }
) ;

# Lifted glist functions:
append_cl â† ( Î» l1 . Î» l2 .
    limit_gl ( boxI ( append_gl ( unbox l2 ) ) ) l1
) ;
take_cl â† ( Î» n .
    limit_gl ( boxI ( take_gl n ) )
) ;
edit_cl â† ( Î» n . Î» func . 
    limit_gl ( boxI ( edit_gl n func ) )
) ;
map_cl â† ( Î» func .
    limit_gl ( boxI ( map_gl func ) )
) ;

# Folds must be hard coded
# Otherwise ill-typed (see section below)
foldl_4 â† ( Î» func . Î» val . Î» list . 
    func ( func ( func ( func 
                val
                ( head list ) 
            ) ( l_2nd list )
        ) ( l_3rd list )
    ) ( l_4th list )
) ;

# Indexation must be hard coded
# Otherwise ill-typed (see section below)
index_cheat â† ( Î» idx . Î» list .
    if ( idx = 0 ) 
        then head list
        else ( if ( idx = 1 )
            then l_2nd list
            else ( if ( idx = 2 )
                then l_3rd list
                else l_4th list
            )
        )
) ;

# Beyond this point, things aren't well typed
# =========================================================
# What is the length of an infinite list ?
length_cl â† ( fix f . Î» l .
    match ( out ( unbox l ) ) {
        inL x â†’ 0 ;
        inR y â†’ 1 + prevI ( f âŠ™ next ( tail l ) )
    }
) ;

# Cannot get to an arbitrary index without nexts
#   Each recursion step adds a next that cannot be prevd
#   as it contains the recursion variable which must, by
#   definition be of type: |>( A -> B )
index_cl â† ( fix f . Î» idx . Î» list .
    if ( idx = 0 )
        then head list
        else prevI ( f âŠ™ next (idx - 1) âŠ™ next (tail list) )
) ;

# What is the end result of a fold on an infinite list?
foldl_cl â† ( fix f . Î» func . Î» val . Î» list .
    match ( out ( unbox list ) ) {
        inL end â†’ val ;
        inR lst â†’ prevI ( 
            f âŠ™ next func 
              âŠ™ next ( func ( head list ) val )
              âŠ™ next ( tail list )
        )
    }
) ;

foldr_cl â† ( fix f . Î» func . Î» val . Î» list .
    match ( out ( unbox list ) ) {
        inL end â†’ val ;
        inR lst â†’ func ( prevI ( 
            f âŠ™ next func 
              âŠ™ next ( val )
              âŠ™ next ( tail l )
        ) ) ( head l )
    }
) ;

in: builtin
