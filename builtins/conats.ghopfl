# Defines the conatural numbers of type
#   Î¼ A . 1 + > A
let

co_zero â† ( in ( inL ğŸ™ ) ) ;
co_inf  â† ( fix f . in ( inR f ) ) ;

co_succ â† ( Î» n . in ( inR ( next n ) ) ) ;
co_pred â† ( 0 ) ; # only possible with box+

co_isZero â† ( Î» n . match ( out n ) { inL x â†’ true ; inR y â†’ false } ) ;

# ill typed!
co_eq   â† ( fix f . Î» n1 . Î» n2 .
    match ( out n1 ) {
        inL x â†’ if ( co_isZero n2 )
            then true
            else false ;
        inR x â†’ if ( co_isZero n2 )
            then false
            else f âŠ™ next ( pred n1 ) âŠ™ next ( pred n2 )
    }
) ;

# ill typed!
co_sub  â† ( ( fix f . Î» n . Î» n1 . Î» n2 .
    if ( co_eq ( co_add n n1 ) n2 )
        then n
        else f âŠ™ next ( co_succ n ) âŠ™ next n1 âŠ™ next n2
) co_zero ) ;


co_add  â† ( fix f . Î» n1 . Î» n2 .
    match ( out n1 ) {
        inL x â†’ n2 ;
        inR y â†’ in ( inR ( f âŠ™ y âŠ™ next n2 ) )
    }
) ;

# TODO: not right
co_mul  â† ( fix f . Î» n1 . Î» n2 .
    match ( out n1 ) {
        inL x â†’ co_zero ;
        inR y â†’ co_add ( in ( inR ( f âŠ™ y âŠ™ next n2 ) ) ) n2
    }
) ;
 
# only possible with box+
co_sub â† ( 0 ) ;


# Conversion
int_to_co  â† ( fix f . Î» n .
    if ( n = 0 ) then co_zero
    else in ( inR ( f âŠ™ next ( n - 1 ) ) )
) ;

# Only for testing, not well typed!
co_to_int â† ( fix f . Î» c . 
    match ( out c ) {
        inL x â†’ 0 ;
        inR y â†’ 1 + prevI ( f âŠ™ y )
    }
) ;

in: builtin
