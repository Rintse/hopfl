# Simulated annealing on the max-cut problem
# Solutions are represented as bitstrings where the boolean values
# indicate in which of the two sets a vertex ends up
# stack run -- -E -d "0.6;0.3;0.4;0.1;0.9;" -e "" -v -i test/tests/annealing.hopfl

let
    # Mathematical tools
    e ← 2.71828 ;
    exp ← (λ x . e ^ x) ;
    neg ← (λ x . 0.0 - x) ;
    xor ← ( λ p . λ q . ( p ∨ q ) ∧ ¬ ( p ∧ q ) ) ;

    # We want to optimize for the following graph:
    # 0 - 1     Here the optimal solution is obviously
    # | \ |     to cut such that the two partitions
    # 3 - 2     are {0, 3} and {1, 2} (4 cuts), as adjacency list:
    graph ← ( [   
        [0,1], [
        [0,2], [
        [0,3], [
        [1,2], [
        [2,3], 0
    ] ] ] ] ] ) ;
    n_edges ← 5 ;
    n_vertices ← 4 ;

    # Initial solution
    init_s ← ([true, [true, [false, [false, 0]]]]) ;  
    # Optimal solution
    opt_s ← ([true, [false, [true, [false, 0]]]]) ;  
    # Initial temperature
    init_temp ← 1.0 ; 

    # List getter
    get ← ( fix f . λ l . λ idx . 
        if (idx = 0)
            then fst l
            else prevI ( f ⊙ next (snd l) ⊙ next (idx-1) )
    ) ;

    # Returns 1.0 if s cuts edge, 0.0 otherwise
    cuts ← ( λ edge . λ s . 
        if ( xor ( get s (fst edge) ) ( get s (snd edge) ) )
            then 1.0 # An edge is cut if its verteces are in different partitions
            else 0.0 # Not cut otherwise
    ) ;

    # The amount of cuts a solution makes (recurstion over adjacency list)
    cut_count ← ( fix f . λ e_idx . λ s .
        if ( e_idx = n_edges ) 
            then 0.0 # End of vector
            else (
                cuts (get graph e_idx) s
                + ( prevI ( f ⊙ next (e_idx + 1) ⊙ next s ) )
            )
    ) ;
    
    # The evaluation function should be lower for better solutions
    eval ← ( λ s . 1.0 / (cut_count 0 s) ) ;

    # Flip bit at given idx
    flip_bit ← ( fix f . λ idx . λ s . 
        if (idx = 0)
            then ([ ¬(fst s), (snd s) ])
            else ([ fst s, prevI ( f ⊙ next (idx-1) ⊙ next (snd s) ) ])
    ) ;

    # Random number (NOT UNIFORM) in [0.0, 1.0]
    rand ← ( ( λ draw . if (draw < 0.0)
        then 0.0
        else (
            if (draw > 1.0)
                then 1.0
                else draw
        ) ) ( normal [0.5, 0.25] )
    ) ;

    # Function that generates a (NOT UNIFORM) random idx between 0 and n
    rand_idx ← ( ( fix f . λ x . λ c .
        if ( x ≥ ( c * (1/n_vertices) ) ) ∧ ( x ≤ ( (c+1) * (1/n_vertices) ) )
            then c # x falls in the interval for idx c
            else prevI (f ⊙ next x ⊙ next (c+1))
        ) rand 0
    ) ;

    # Mutation function, randomly flips one bit in the solution vector
    mutate ← ( flip_bit rand_idx ) ;

    # The chance of accepting a neigbour if it is worse
    p_accept_new ← ( λ old . λ new . λ temp . 
        exp( neg ( ( eval(new) - eval(old) ) / temp ) )
    ) ;

    # Non-deterministically select between neighbour and original
    select ← ( λ old . λ new . λ temp . 
        if ( (eval new) < (eval old) )
            then new
            else (
                if ( rand < ( p_accept_new old new temp ) )
                    then new 
                    else old
            )
    ) ;
    
    # Gets the temperature for round k
    get_temp ← ( λ k . init_temp / (k + 1) ) 

# The actual algorithm
in: print ( (
    fix f . λ k . λ k_max . λ s .
        if (k = k_max)
            then mutate s # Maximum number of iterations reached
            else prevI ( f 
                ⊙ next ( k + 1.0 ) 
                ⊙ next ( k_max ) 
                ⊙ next ( select s ( mutate s ) ( get_temp k ) )
            )
) 0 k_max init_s )

