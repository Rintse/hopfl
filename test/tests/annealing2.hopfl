# Simulated annealing on the max-cut problem
# Solutions are represented as bitstrings where the boolean values
# indicate in which partition a given vertex is contained
# Free variables to pass through the environment:
#   iteration:  The optimization iteration to get the result from
#
# Example run:
#   stack run -- -E -d "0.6;0.3;0.4;0.1;0.9;" -e "" -v -i test/tests/annealing.hopfl
# Should give the optimal, after first accepting a worse solution

let
    # Mathematical tools
    e â† 2.71828 ;
    exp â† (Î» x . e ^ x) ;
    xor â† ( Î» p . Î» q . ( p âˆ¨ q ) âˆ§ Â¬ ( p âˆ§ q ) ) ;
    add â† ( Î» x . Î» y . x + y ) ;

    # Get item at idx in l
    get â† ( fix f . Î» l . Î» idx . 
        match l {
            inL x â†’ false ; # Should not happen
            inR y â†’ if ( idx = 0 )
                then fst y
                else prevI ( f âŠ™ next ( snd y ) âŠ™ next ( idx - 1 ) )
        }
    ) ;
    
    # Flip bit in s at given idx
    flip_bit â† ( fix f . Î» idx . Î» s . 
        match s {
            inL x â†’ false ; # Should not happen
            inR y â†’ if ( idx = 0 )
                then ( inR ( [ Â¬( fst y ), ( snd y ) ] ) )
                else ( inR ( [ fst y, prevI ( f âŠ™ next ( idx-1 ) âŠ™ next ( snd y ) ) ] ) )
        }
    ) ;

    # We want to optimize for the following graph:
    # 0 - 1     Here the optimal solution is to cut 
    # | \ |     such that the two partitions are {0, 3}
    # 3 - 2     and {1, 2} (4 cuts), as adjacency list:
    graph â† (  inR ( [
        [0,1], inR ( [ 
        [0,2], inR ( [ 
        [0,3], inR ( [ 
        [1,2], inR ( [ 
        [2,3], inL ğŸ™ ] 
    ) ] ) ] ) ] ) ] ) ) ;

    # Initial solution
    init_s â† (  inR ( [ 
        true,   inR ( [
        true,   inR ( [
        false,  inR ( [
        false,  inL ğŸ™ ]
    ) ] ) ] ) ] ) ) ; 
    n_vertices â† length init_s ;
    # Initial temperature
    init_temp â† 1.0 ; 

    # Returns 1.0 if s cuts edge, 0.0 otherwise
    # An edge is cut if its verteces are in different partitions
    cuts â† ( Î» s . Î» edge .
        if ( xor ( get s ( fst edge ) ) ( get s ( snd edge ) ) ) then 1 else 0
    ) ;

    # The amount of cuts a solution makes (recurstion over adjacency list)
    cut_count â† ( Î» s . foldl add 0 ( map ( cuts s ) graph ) ) ;
    
    # The evaluation function should be lower for better solutions
    eval â† ( Î» s . 1.0 / ( cut_count s ) ) ;

    # Random number (NOT UNIFORM) in [0.0, 1.0]
    rand â† ( ( Î» draw . 
        if (draw < 0.0)
            then 0.0
            else (
                if (draw > 1.0)
                    then 1.0
                    else draw
            ) 
        ) ( normal [0.5, 0.25] )
    ) ;


    # Function that generates a (NOT UNIFORM) random idx between 0 and n
    rand_idx â† ( ( fix f . Î» r . Î» n . Î» c . Î» inc .
        if ( n = (n_vertices-1) ) then n else (  # Catch rounding errors
            if ( r â‰¥ c ) âˆ§ ( r < ( c + inc ) )
                then n # x falls in the interval for idx n
                else prevI (f âŠ™ next r âŠ™ next (n+1) âŠ™ next (c+inc) âŠ™ next inc)
        ) ) rand 0 0.0 (1 / n_vertices)
    ) ;

    # Mutation function, randomly flips one bit in the solution vector
    mutate â† ( flip_bit rand_idx ) ;

    # The chance of accepting a neigbour if it is worse
    p_accept_new â† ( Î» old . Î» new . Î» temp . 
        exp( - ( ( eval(new) - eval(old) ) / temp ) )
    ) ;

    # Non-deterministically select between neighbour and original
    select â† ( Î» old . Î» new . Î» temp . 
        if ( (eval new) < (eval old) )
            then new
            else (
                if ( rand < ( p_accept_new old new temp ) )
                    then new 
                    else old
            )
    ) ;
    
    # Gets the temperature for round k
    get_temp â† ( Î» k . init_temp / (k + 1) ) ; 

    # The optimization stream
    opt_stream â† ( boxI ( ( fix f . Î» k . Î» s . in (
        [ s, f âŠ™ next ( k + 1 ) 
               âŠ™ next ( select s ( mutate s ) ( get_temp k ) ) 
        ] ) ) 0 init_s )
    ) ;

    # Get the result at iteration idx
    get_result â† ( fix f . Î» idx . Î» stream .
        if (idx = 0)
            then head stream
            else prevI ( f âŠ™ next (idx - 1) âŠ™ next (tail stream) )
    )

# in: print ( mutate init_s )
in: print ( get_result iteration opt_stream )

